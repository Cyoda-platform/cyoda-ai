{"messages": [{"role": "system", "content": "You are a cyoda application builder assistant"}, {"role": "user", "content": "Please, generate the processor functions for flight_search_job call public functions by the name of each processor: search_flights, notify_no_flights, handle_api_error.  Reuse functions that are available in the code base, including logic.app_init import entity_service, connections.py (ingest_data public function) and any other existing function that is related to your purpose. Make sure you include logic to save any dependant entities: flight_results_entity, no_flight_notification_entity, error_notification_entity. Also generate tests with mocks for external services or functions so that the user can try out the functions right away in isolated environment. **Tests should be in the same file with the code**flight_search_job. Based on the user suggestions if there are any.  Please make sure you are re-using all raw_data_*/connections/connection.py ingest_data functions. This is very important not to re-implement ingest_data but reuse it. You should import and reuse all ingest_data functions, use 'as' to avoid names duplicates. Make sure the result of data ingestion is saved to the corresponding raw data entity. Please also make sure that you understand that argument 'data' that you pass to each function corresponds to entity/flight_search_job/flight_search_job.json data and not to any other entity! User says: : I've already provided all the necessary details in the session context"}, {"role": "assistant", "content": "```python\nimport asyncio\\nimport copy\\nimport logging\\nfrom app_init.app_init import entity_service\\nfrom entity.flight_results_entity.connections.connections import ingest_data\\n\\nlogging.basicConfig(level=logging.INFO)\\nlogger = logging.getLogger(__name__)\\n\\nasync def search_flights(meta, data):\\n    \\\"\\\"\\\"Trigger the flight search based on user input.\\\"\\\"\\\"\\n    logger.info(\"Starting flight search process.\")\\n    try:\\n        flight_data = await ingest_data()\\n\\n        flight_results_id = await entity_service.add_item(\\n            meta[\"token\"], \"flight_results_entity\", \"1.0\", flight_data\\n        )\\n        data[\"flight_results_entity\"] = {\"technical_id\": flight_results_id}\\n        logger.info(f\"Flight results saved with ID: {flight_results_id}\")\\n\\n    except Exception as e:\\n        logger.error(f\"Error in search_flights: {e}\")\\n        await handle_api_error(meta, data)\\n\\n\\nasync def notify_no_flights(meta, data):\\n    \\\"\\\"\\\"Notify the user that no flights were found.\\\"\\\"\\\"\\n    logger.info(\"Notifying user that no flights were found.\")\\n    try:\\n        notification_data = {\\n            \"notification_id\": \"notification_001\",\\n            \"message\": \"No flights were found matching your search criteria.\",\\n            \"search_criteria\": {\\n                \"departure_airport\": data[\"departure_airport\"],\\n                \"arrival_airport\": data[\"arrival_airport\"],\\n                \"travel_dates\": data[\"travel_dates\"],\\n                \"number_of_passengers\": data[\"number_of_passengers\"],\\n            },\\n            \"timestamp\": \"2023-10-01T10:05:00Z\",\\n            \"user_contact\": {\\n                \"email\": \"user@example.com\",\\n                \"phone\": \"+1234567890\"\\n            },\\n            \"suggestions\": [\\n                \"Try adjusting your travel dates.\",\\n                \"Consider searching from nearby airports.\",\\n                \"Check back later for updated flight availability.\"\\n            ]\\n        }\\n\\n        no_flight_notification_id = await entity_service.add_item(\\n            meta[\"token\"], \"no_flight_notification_entity\", \"1.0\", notification_data\\n        )\\n        data[\"no_flight_notification_entity\"] = {\"technical_id\": no_flight_notification_id}\\n        logger.info(f\"No flight notification saved with ID: {no_flight_notification_id}\")\\n    except Exception as e:\\n        logger.error(f\"Error in notify_no_flights: {e}\")\\n        raise\\n\\n\\nasync def handle_api_error(meta, data):\\n    \\\"\\\"\\\"Handle errors that occur during the API call.\\\"\\\"\\\"\\n    logger.info(\"Handling API error during flight search.\")\\n    try:\\n        error_data = {\\n            \"notification_id\": \"error_notification_001\",\\n            \"timestamp\": \"2023-10-01T12:00:00Z\",\\n            \"status\": \"error\",\\n            \"message\": \"An error occurred while trying to fetch flight data from the Airport Gap API.\",\\n            \"details\": {\\n                \"error_code\": \"API_CALL_FAILURE\",\\n                \"failed_request\": {\\n                    \"url\": \"https://airportgap.com/api/airports\",\\n                    \"method\": \"GET\"\\n                },\\n                \"retry_suggestion\": \"Please try again later or check your internet connection.\"\\n            },\\n            \"user_notification\": {\\n                \"user_id\": data[\"user_id\"],\\n                \"email\": \"user@example.com\",\\n                \"notification_sent\": True\\n            }\\n        }\\n\\n        error_notification_id = await entity_service.add_item(\\n            meta[\"token\"], \"error_notification_entity\", \"1.0\", error_data\\n        )\\n        data[\"error_notification_entity\"] = {\"technical_id\": error_notification_id}\\n        logger.info(f\"Error notification saved with ID: {error_notification_id}\")\\n    except Exception as e:\\n        logger.error(f\"Error in handle_api_error: {e}\")\\n        raise\\n\\n\\nimport unittest\\nfrom unittest.mock import patch\\n\\nclass TestFlightSearchJob(unittest.TestCase):\\n    @patch(\"workflow.ingest_data\")\\n    @patch(\"app_init.app_init.entity_service.add_item\")\\n    def test_search_flights_success(self, mock_add_item, mock_ingest_data):\\n        ingested_data = {\\n            \"data\": [{\\n                \"attributes\": {\\n                    \"altitude\": 5283,\\n                    \"city\": \"Goroka\",\\n                    \"country\": \"Papua New Guinea\",\\n                    \"iata\": \"GKA\",\\n                    \"icao\": \"AYGA\",\\n                    \"latitude\": \"-6.08169\",\\n                    \"longitude\": \"145.391998\",\\n                    \"name\": \"Goroka Airport\",\\n                    \"timezone\": \"Pacific/Port_Moresby\"\\n                },\\n                \"id\": \"GKA\",\\n                \"type\": \"airport\"\\n            },\\n                {\\n                    \"attributes\": {\\n                        \"altitude\": 20,\\n                        \"city\": \"Madang\",\\n                        \"country\": \"Papua New Guinea\",\\n                        \"iata\": \"MAG\",\\n                        \"icao\": \"AYMD\",\\n                        \"latitude\": \"-5.20708\",\\n                        \"longitude\": \"145.789001\",\\n                        \"name\": \"Madang Airport\",\\n                        \"timezone\": \"Pacific/Port_Moresby\"\\n                    },\\n                    \"id\": \"MAG\",\\n                    \"type\": \"airport\"\\n                }]\\n        }\\n        mock_ingest_data.return_value = ingested_data\\n\\n        mock_add_item.return_value = \"flight_results_id\"\\n\\n        meta = {\"token\": \"test_token\"}\\n        data = {\\n            \"departure_airport\": \"JFK\",\\n            \"arrival_airport\": \"LAX\",\\n            \"travel_dates\": {\\n                \"departure_date\": \"2023-12-01\",\\n                \"return_date\": \"2023-12-10\"\\n            },\\n            \"number_of_passengers\": 2\\n        }\\n\\n        asyncio.run(search_flights(meta, data))\\n\\n        mock_add_item.assert_called_once_with(\\n            meta[\"token\"], \"flight_results_entity\", \"1.0\", ingested_data\\n        )\\n\\nif __name__ == \"__main__\":\\n    unittest.main()\n ```"}]}