{
        "ai_endpoint": "cyoda",
        "question": "Please remember these files contents and reuse later: [{\"common/service/entity_service_interface.py\": \"from abc import ABC, abstractmethod\\nfrom typing import List, Any\\n\\nclass EntityService(ABC):\\n\\n    @abstractmethod\\n    async def get_item(self, token: str, entity_model: str, entity_version: str, id: str) -> Any:\\n        \\\"\\\"\\\"Retrieve a single item based on its ID.\\\"\\\"\\\"\\n        pass\\n\\n    @abstractmethod\\n    async def get_items(self, token: str, entity_model: str, entity_version: str) -> List[Any]:\\n        \\\"\\\"\\\"Retrieve multiple items based on their IDs.\\\"\\\"\\\"\\n        pass\\n\\n    @abstractmethod\\n    async def get_single_item_by_condition(self, token: str, entity_model: str, entity_version: str, condition: Any) -> List[Any]:\\n        \\\"\\\"\\\"Retrieve multiple items based on their IDs.\\\"\\\"\\\"\\n        pass\\n\\n    @abstractmethod\\n    async def get_items_by_condition(self, token: str, entity_model: str, entity_version: str, condition: Any) -> List[Any]:\\n        \\\"\\\"\\\"Retrieve multiple items based on their IDs.\\\"\\\"\\\"\\n        pass\\n\\n    @abstractmethod\\n    async def add_item(self, token: str, entity_model: str, entity_version: str, entity: Any) -> Any:\\n        \\\"\\\"\\\"Add a new item to the repository.\\\"\\\"\\\"\\n        pass\\n\\n    @abstractmethod\\n    async def update_item(self, token: str, entity_model: str, entity_version: str, id: str, entity: Any, meta: Any) -> Any:\\n        \\\"\\\"\\\"Update an existing item in the repository.\\\"\\\"\\\"\\n        pass\"}, {\"common/service/trino_service.py\": \"from common.config.config import CYODA_AI_URL\\nfrom common.util.utils import send_post_request\\n\\nasync def get_trino_schema_id_by_entity_name(entity_name: str):\\n    return \\\"2f303900-d8e3-11ef-a78b-ea51a4527ea1\\\"\\n\\n#runs sql to retrieve data\\nasync def run_sql_query(token, query):\\n    resp = await send_post_request(token, CYODA_AI_URL, \\\"api/v1/trino/run-query\\\", query)\\n    return resp[\\\"message\\\"]\"}, {\"common/ai/ai_assistant_service.py\": \"from abc import ABC, abstractmethod\\n\\nclass IAiAssistantService(ABC):\\n    @abstractmethod\\n    def init_chat(self, token: str, chat_id: str) -> dict:\\n        \\\"\\\"\\\"Initialize chat sessions for all AI endpoints\\n\\n        Args:\\n            token: Authentication token\\n            chat_id: Unique chat identifier\\n\\n        Returns:\\n            dict: Success status of initialization\\n        \\\"\\\"\\\"\\n        pass\\n\\n    @abstractmethod\\n    def ai_chat(self, token: str, chat_id: str, ai_endpoint: str, ai_question: str) -> dict:\\n        \\\"\\\"\\\"Send chat message to appropriate AI endpoint\\n\\n        Args:\\n            token: Authentication token\\n            chat_id: Unique chat identifier\\n            ai_endpoint: Target AI endpoint to route message to, enum ['random', 'trino'], trino is used for data retrieval, data aggregation\\n            ai_question: Chat message/question to send\\n\\n        Returns:\\n            dict: AI response message\\n\\n        Raises:\\n            ValueError: If ai_endpoint is not recognized\\n        \\\"\\\"\\\"\\n        pass\\n\\n\"}, {\"processor_instruction.txt\": \"import json\\nimport logging\\nimport os\\nimport asyncio\\n\\nfrom app_init.app_init import ai_service, entity_service\\nfrom common.config.config import ENTITY_VERSION, TRINO_AI_API\\nfrom common.service.trino_service import get_trino_schema_id_by_entity_name\\nfrom common.util.utils import read_json_file, parse_json\\n\\nlogging.basicConfig(level=logging.INFO)\\nlogger = logging.getLogger(__name__)\\n\\n# Use meta to get token.\\n# 'data' is the current entity data. You can find the entity data model in {current_entity_name}.json file, which is available in your session context.\\n# Study the data model before writing any code.\\n# In the process function, you can work with the current entity data, analyze it, get other entities to which the current entity has references, and add new \\\"dependent\\\" entities.\\n\\nasync def process_name(meta, data):\\n    \\\"\\\"\\\"Example process function. This is where the core business logic goes.\\\"\\\"\\\"\\n    try:\\n        # Retrieve the entity based on its ID from the entity service.\\n        entity = await entity_service.get_item(meta[\\\"token\\\"], some_entity_name, ENTITY_VERSION, data[\\\"id\\\"])\\n\\n        # Process the entity and create a dependent entity.\\n        dependant_entity_data = data[\\\"dependent_entity_data\\\"]\\n\\n        # Add the dependent entity using the entity service.\\n        dependant_entity_id = await entity_service.add_item(\\n            meta[\\\"token\\\"], dependant_entity_name, ENTITY_VERSION, dependant_entity_data\\n        )\\n        data[\\\"dependent_entity\\\"] = {\\\"technical_id\\\": dependant_entity_id}\\n        #no need to update current entity - it will be done automatically, but dependant entities should be updated manually if necessary\\n        logger.info(\\\"Dependent entity added successfully.\\\")\\n    except Exception as e:\\n        logger.error(f\\\"Error in process_name: {e}\\\")\\n        raise\\n\\n\\nasync def data_aggregation_process_name(meta, data):\\n    \\\"\\\"\\\"Example of an asynchronous function to aggregate data.\\\"\\\"\\\"\\n    try:\\n        # Read the schema file that defines the structure for aggregated data.\\n        base_dir = os.path.abspath(os.path.join(__file__, \\\"../../../\\\"))\\n        aggregated_data_entity_path = os.path.join(base_dir, 'aggregated_data_entity', 'aggregated_data_entity.json')\\n        aggregated_data_entity_schema = await read_json_file(aggregated_data_entity_path)\\n\\n        # Make API call to AI service to generate aggregated data report based on schema.\\n        aggregated_data = await ai_service.ai_chat(\\n            token=meta[\\\"token\\\"],\\n            chat_id=await get_trino_schema_id_by_entity_name(\\\"response_data_entity\\\"),\\n            ai_endpoint=TRINO_AI_API,\\n            ai_question=f\\\"Could you please return json report based on this schema: {json.dumps(aggregated_data_entity_schema)}. Return only json\\\"\\n        )\\n\\n        # Parse and validate the returned JSON data.\\n        aggregated_data_entity_data = json.loads(parse_json(aggregated_data))\\n\\n        # Store the aggregated data entity and get its ID.\\n        aggregated_data_entity_id = await entity_service.add_item(\\n            meta[\\\"token\\\"], \\\"aggregated_data_entity\\\", ENTITY_VERSION, aggregated_data_entity_data\\n        )\\n\\n        logger.info(\\\"Aggregated data entity added successfully.\\\")\\n    except Exception as e:\\n        logger.error(f\\\"Error in data_aggregation_process_name: {e}\\\")\\n        raise\\n\\n# Test example to show how to handle async function calls in unit tests:\\n\\nclass TestSendEmailProcess(unittest.TestCase):\\n\\n    @patch(\\\"app_init.app_init.entity_service.add_item\\\")\\n    @patch(\\\"app_init.app_init.ai_service.ai_chat\\\")\\n    def test_send_email_process(self, mock_ai_chat, mock_entity_service):\\n        # Arrange: mock dependencies\\n        mock_ai_chat.return_value = '{\\\"aggregated_data\\\": \\\"dummy_aggregated_data\\\"}'\\n        mock_entity_service.return_value = \\\"aggregated_data_entity_id\\\"\\n\\n        meta = {\\\"token\\\": \\\"test_token\\\"}\\n        data = {}\\n\\n        # Act: Execute the async function using asyncio.run()\\n        asyncio.run(data_aggregation_process_name(meta, data))\\n\\n        # Assert: Verify that the correct methods were called with the expected arguments\\n        mock_entity_service.assert_called_once_with(\\n            meta[\\\"token\\\"], \\\"aggregated_data_entity\\\", ENTITY_VERSION, {\\\"aggregated_data\\\": \\\"dummy_aggregated_data\\\"}\\n        )\\n\\n# Uncomment the line below to run the tests when this script is executed directly\\nif __name__ == '__main__':\\n    unittest.main()\\n\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/no_flight_notification_entity/no_flight_notification_entity.json\": \"{\\n    \\\"notification_id\\\": \\\"notification_001\\\",\\n    \\\"message\\\": \\\"No flights were found matching your search criteria.\\\",\\n    \\\"search_criteria\\\": {\\n        \\\"departure_airport\\\": \\\"GKA\\\",\\n        \\\"arrival_airport\\\": \\\"MAG\\\",\\n        \\\"travel_dates\\\": {\\n            \\\"departure\\\": \\\"2023-10-15\\\",\\n            \\\"return\\\": \\\"2023-10-22\\\"\\n        },\\n        \\\"number_of_passengers\\\": 2\\n    },\\n    \\\"timestamp\\\": \\\"2023-10-01T10:05:00Z\\\",\\n    \\\"user_contact\\\": {\\n        \\\"email\\\": \\\"user@example.com\\\",\\n        \\\"phone\\\": \\\"+1234567890\\\"\\n    },\\n    \\\"suggestions\\\": [\\n        \\\"Try adjusting your travel dates.\\\",\\n        \\\"Consider searching from nearby airports.\\\",\\n        \\\"Check back later for updated flight availability.\\\"\\n    ]\\n}\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/error_notification_entity/error_notification_entity.json\": \"{\\n    \\\"notification_id\\\": \\\"notification_001\\\",\\n    \\\"timestamp\\\": \\\"2023-10-01T12:00:00Z\\\",\\n    \\\"status\\\": \\\"error\\\",\\n    \\\"message\\\": \\\"An error occurred while trying to fetch flight data from the Airport Gap API.\\\",\\n    \\\"details\\\": {\\n        \\\"error_code\\\": \\\"API_CALL_FAILURE\\\",\\n        \\\"failed_request\\\": {\\n            \\\"url\\\": \\\"https://airportgap.com/api/airports\\\",\\n            \\\"method\\\": \\\"GET\\\"\\n        },\\n        \\\"retry_suggestion\\\": \\\"Please try again later or check your internet connection.\\\"\\n    },\\n    \\\"user_notification\\\": {\\n        \\\"user_id\\\": \\\"user_123\\\",\\n        \\\"email\\\": \\\"user@example.com\\\",\\n        \\\"notification_sent\\\": true\\n    }\\n}\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_results_entity/connections/connections_input.md\": \"curl https://airportgap.com/api/airports\\nExample of successful response Status: 200 OK\\n\\n{\\n  \\\"data\\\": [{\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 5282,\\n        \\\"city\\\": \\\"Goroka\\\",\\n        \\\"country\\\": \\\"Papua New Guinea\\\",\\n        \\\"iata\\\": \\\"GKA\\\",\\n        \\\"icao\\\": \\\"AYGA\\\",\\n        \\\"latitude\\\": \\\"-6.08169\\\",\\n        \\\"longitude\\\": \\\"145.391998\\\",\\n        \\\"name\\\": \\\"Goroka Airport\\\",\\n        \\\"timezone\\\": \\\"Pacific/Port_Moresby\\\"\\n\\n      },\\n      \\\"id\\\": \\\"GKA\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    },\\n    {\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 20,\\n        \\\"city\\\": \\\"Madang\\\",\\n        \\\"country\\\": \\\"Papua New Guinea\\\",\\n        \\\"iata\\\": \\\"MAG\\\",\\n        \\\"icao\\\": \\\"AYMD\\\",\\n        \\\"latitude\\\": \\\"-5.20708\\\",\\n        \\\"longitude\\\": \\\"145.789001\\\",\\n        \\\"name\\\": \\\"Madang Airport\\\",\\n        \\\"timezone\\\": \\\"Pacific/Port_Moresby\\\"\\n      },\\n      \\\"id\\\": \\\"MAG\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    },\\n\\n    ...\\n\\n    {\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 1343,\\n        \\\"city\\\": \\\"Brandon\\\",\\n        \\\"country\\\": \\\"Canada\\\",\\n        \\\"iata\\\": \\\"YBR\\\",\\n        \\\"icao\\\": \\\"CYBR\\\",\\n        \\\"latitude\\\": \\\"49.91\\\",\\n        \\\"longitude\\\": \\\"-99.951897\\\",\\n        \\\"name\\\": \\\"Brandon Municipal Airport\\\",\\n        \\\"timezone\\\": \\\"America/Winnipeg\\\"\\n      },\\n      \\\"id\\\": \\\"YBR\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    },\\n    {\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 90,\\n        \\\"city\\\": \\\"Cambridge Bay\\\",\\n        \\\"country\\\": \\\"Canada\\\",\\n        \\\"iata\\\": \\\"YCB\\\",\\n        \\\"icao\\\": \\\"CYCB\\\",\\n        \\\"latitude\\\": \\\"69.108101\\\",\\n        \\\"longitude\\\": \\\"-105.138\\\",\\n        \\\"name\\\": \\\"Cambridge Bay Airport\\\",\\n        \\\"timezone\\\": \\\"America/Edmonton\\\"\\n      },\\n      \\\"id\\\": \\\"YCB\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    }\\n  ],\\n  \\\"links\\\": {\\n    \\\"first\\\": \\\"https://airportgap.com/api/airports\\\",\\n    \\\"last\\\": \\\"https://airportgap.com/api/airports?page=203\\\",\\n    \\\"next\\\": \\\"https://airportgap.com/api/airports?page=2\\\",\\n    \\\"prev\\\": \\\"https://airportgap.com/api/airports\\\",\\n    \\\"self\\\": \\\"https://airportgap.com/api/airports\\\"\\n  }\\n}\\n\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_results_entity/connections/__init__.py\": \"\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_results_entity/connections/connections.py\": \"# ```python\\nimport asyncio\\nimport logging\\nimport aiohttp\\nimport unittest\\nfrom unittest.mock import patch\\n\\nlogging.basicConfig(level=logging.INFO)\\nlogger = logging.getLogger(__name__)\\n\\nAPI_URL = \\\"https://airportgap.com/api/airports\\\"\\n\\nasync def fetch_data():\\n    async with aiohttp.ClientSession() as session:\\n        try:\\n            async with session.get(API_URL) as response:\\n                if response.status == 200:\\n                    return await response.json()\\n                else:\\n                    logger.error(f\\\"Error fetching data: {response.status}\\\")\\n                    return None\\n        except Exception as e:\\n            logger.error(f\\\"Exception occurred: {str(e)}\\\")\\n            return None\\n\\nasync def ingest_data() -> list:\\n    data = await fetch_data()\\n    if data is None:\\n        logger.error(\\\"No data received for ingestion.\\\")\\n        return []\\n    \\n    # Map raw data to the entity structure\\n    mapped_data = [\\n        {\\n            \\\"id\\\": airport[\\\"id\\\"],\\n            \\\"name\\\": airport[\\\"attributes\\\"][\\\"name\\\"],\\n            \\\"city\\\": airport[\\\"attributes\\\"][\\\"city\\\"],\\n            \\\"country\\\": airport[\\\"attributes\\\"][\\\"country\\\"],\\n            \\\"iata\\\": airport[\\\"attributes\\\"][\\\"iata\\\"],\\n            \\\"icao\\\": airport[\\\"attributes\\\"][\\\"icao\\\"],\\n            \\\"latitude\\\": airport[\\\"attributes\\\"][\\\"latitude\\\"],\\n            \\\"longitude\\\": airport[\\\"attributes\\\"][\\\"longitude\\\"],\\n            \\\"altitude\\\": airport[\\\"attributes\\\"][\\\"altitude\\\"],\\n            \\\"timezone\\\": airport[\\\"attributes\\\"][\\\"timezone\\\"]\\n        }\\n        for airport in data.get(\\\"data\\\", [])\\n    ]\\n\\n    return mapped_data\\n\\nclass TestDataIngestion(unittest.TestCase):\\n\\n    @patch(\\\"aiohttp.ClientSession.get\\\")\\n    def test_ingest_data_success(self, mock_get):\\n        # Mock the API response\\n        mock_get.return_value.__aenter__.return_value.status = 200\\n        mock_get.return_value.__aenter__.return_value.json = asyncio.Future()\\n        mock_get.return_value.__aenter__.return_value.json.set_result({\\n            \\\"data\\\": [\\n                {\\n                    \\\"attributes\\\": {\\n                        \\\"altitude\\\": 5282,\\n                        \\\"city\\\": \\\"Goroka\\\",\\n                        \\\"country\\\": \\\"Papua New Guinea\\\",\\n                        \\\"iata\\\": \\\"GKA\\\",\\n                        \\\"icao\\\": \\\"AYGA\\\",\\n                        \\\"latitude\\\": \\\"-6.08169\\\",\\n                        \\\"longitude\\\": \\\"145.391998\\\",\\n                        \\\"name\\\": \\\"Goroka Airport\\\",\\n                        \\\"timezone\\\": \\\"Pacific/Port_Moresby\\\"\\n                    },\\n                    \\\"id\\\": \\\"GKA\\\",\\n                    \\\"type\\\": \\\"airport\\\"\\n                }\\n            ]\\n        })\\n\\n        # Run the ingest_data function\\n        result = asyncio.run(ingest_data())\\n\\n        # Assertions to check that data is mapped correctly\\n        self.assertEqual(len(result), 1)\\n        self.assertEqual(result[0][\\\"id\\\"], \\\"GKA\\\")\\n        self.assertEqual(result[0][\\\"name\\\"], \\\"Goroka Airport\\\")\\n        self.assertEqual(result[0][\\\"city\\\"], \\\"Goroka\\\")\\n        self.assertEqual(result[0][\\\"country\\\"], \\\"Papua New Guinea\\\")\\n        self.assertEqual(result[0][\\\"iata\\\"], \\\"GKA\\\")\\n        self.assertEqual(result[0][\\\"icao\\\"], \\\"AYGA\\\")\\n        self.assertEqual(result[0][\\\"latitude\\\"], \\\"-6.08169\\\")\\n        self.assertEqual(result[0][\\\"longitude\\\"], \\\"145.391998\\\")\\n        self.assertEqual(result[0][\\\"altitude\\\"], 5282)\\n        self.assertEqual(result[0][\\\"timezone\\\"], \\\"Pacific/Port_Moresby\\\")\\n\\nif __name__ == \\\"__main__\\\":\\n    unittest.main()\\n# ``` \\n# \\n# ### Explanation of the Code\\n# \\n# 1. **`fetch_data()` Function**:\\n#    - Asynchronously retrieves JSON data from the specified Airport Gap API URL using `aiohttp`.\\n#    - It checks the response status; if successful (status 200), it returns the JSON response.\\n# \\n# 2. **`ingest_data()` Function**:\\n#    - Calls `fetch_data()` to get the airport data.\\n#    - If data is retrieved successfully, it maps the relevant fields from the raw response to a structured format.\\n#    - The resulting list of mapped airport data is returned.\\n# \\n# 3. **Unit Tests**:\\n#    - The `TestDataIngestion` class contains a test method `test_ingest_data_success` that mocks the API response to simulate a successful data retrieval.\\n#    - Assertions are made to ensure the mapped data is correct and matches the expected output.\\n# \\n# This setup allows for easy testing of the data ingestion process in an isolated environment without making actual API calls.\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_results_entity/flight_results_entity.json\": \"{\\n  \\\"data\\\": [{\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 5282,\\n        \\\"city\\\": \\\"Goroka\\\",\\n        \\\"country\\\": \\\"Papua New Guinea\\\",\\n        \\\"iata\\\": \\\"GKA\\\",\\n        \\\"icao\\\": \\\"AYGA\\\",\\n        \\\"latitude\\\": \\\"-6.08169\\\",\\n        \\\"longitude\\\": \\\"145.391998\\\",\\n        \\\"name\\\": \\\"Goroka Airport\\\",\\n        \\\"timezone\\\": \\\"Pacific/Port_Moresby\\\"\\n\\n      },\\n      \\\"id\\\": \\\"GKA\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    },\\n    {\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 20,\\n        \\\"city\\\": \\\"Madang\\\",\\n        \\\"country\\\": \\\"Papua New Guinea\\\",\\n        \\\"iata\\\": \\\"MAG\\\",\\n        \\\"icao\\\": \\\"AYMD\\\",\\n        \\\"latitude\\\": \\\"-5.20708\\\",\\n        \\\"longitude\\\": \\\"145.789001\\\",\\n        \\\"name\\\": \\\"Madang Airport\\\",\\n        \\\"timezone\\\": \\\"Pacific/Port_Moresby\\\"\\n      },\\n      \\\"id\\\": \\\"MAG\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    },\\n\\n    ...\\n\\n    {\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 1343,\\n        \\\"city\\\": \\\"Brandon\\\",\\n        \\\"country\\\": \\\"Canada\\\",\\n        \\\"iata\\\": \\\"YBR\\\",\\n        \\\"icao\\\": \\\"CYBR\\\",\\n        \\\"latitude\\\": \\\"49.91\\\",\\n        \\\"longitude\\\": \\\"-99.951897\\\",\\n        \\\"name\\\": \\\"Brandon Municipal Airport\\\",\\n        \\\"timezone\\\": \\\"America/Winnipeg\\\"\\n      },\\n      \\\"id\\\": \\\"YBR\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    },\\n    {\\n      \\\"attributes\\\": {\\n        \\\"altitude\\\": 90,\\n        \\\"city\\\": \\\"Cambridge Bay\\\",\\n        \\\"country\\\": \\\"Canada\\\",\\n        \\\"iata\\\": \\\"YCB\\\",\\n        \\\"icao\\\": \\\"CYCB\\\",\\n        \\\"latitude\\\": \\\"69.108101\\\",\\n        \\\"longitude\\\": \\\"-105.138\\\",\\n        \\\"name\\\": \\\"Cambridge Bay Airport\\\",\\n        \\\"timezone\\\": \\\"America/Edmonton\\\"\\n      },\\n      \\\"id\\\": \\\"YCB\\\",\\n      \\\"type\\\": \\\"airport\\\"\\n    }\\n  ],\\n  \\\"links\\\": {\\n    \\\"first\\\": \\\"https://airportgap.com/api/airports\\\",\\n    \\\"last\\\": \\\"https://airportgap.com/api/airports?page=203\\\",\\n    \\\"next\\\": \\\"https://airportgap.com/api/airports?page=2\\\",\\n    \\\"prev\\\": \\\"https://airportgap.com/api/airports\\\",\\n    \\\"self\\\": \\\"https://airportgap.com/api/airports\\\"\\n  }\\n}\\n\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_search_job/workflow/__init__.py\": \"\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_search_job/workflow/workflow.json\": \"{\\n    \\\"name\\\": \\\"flight_search_workflow\\\",\\n    \\\"description\\\": \\\"Workflow for searching flights and handling results.\\\",\\n    \\\"workflow_criteria\\\": {\\n        \\\"externalized_criteria\\\": [],\\n        \\\"condition_criteria\\\": [\\n            {\\n                \\\"name\\\": \\\"flight_search_job\\\",\\n                \\\"description\\\": \\\"Workflow criteria\\\",\\n                \\\"condition\\\": {\\n                    \\\"group_condition_operator\\\": \\\"AND\\\",\\n                    \\\"conditions\\\": [\\n                        {\\n                            \\\"field_name\\\": \\\"entityModelName\\\",\\n                            \\\"is_meta_field\\\": true,\\n                            \\\"operation\\\": \\\"equals\\\",\\n                            \\\"value\\\": \\\"flight_search_job\\\",\\n                            \\\"value_type\\\": \\\"strings\\\"\\n                        }\\n                    ]\\n                }\\n            }\\n        ]\\n    },\\n    \\\"transitions\\\": [\\n        {\\n            \\\"name\\\": \\\"start_flight_search\\\",\\n            \\\"description\\\": \\\"Trigger the flight search based on user input.\\\",\\n            \\\"start_state\\\": \\\"None\\\",\\n            \\\"start_state_description\\\": \\\"Initial state before flight search.\\\",\\n            \\\"end_state\\\": \\\"flights_found\\\",\\n            \\\"end_state_description\\\": \\\"Flights have been successfully retrieved from the API.\\\",\\n            \\\"automated\\\": true,\\n            \\\"transition_criteria\\\": {\\n                \\\"externalized_criteria\\\": [],\\n                \\\"condition_criteria\\\": []\\n            },\\n            \\\"processes\\\": {\\n                \\\"schedule_transition_processors\\\": [],\\n                \\\"externalized_processors\\\": [\\n                    {\\n                        \\\"name\\\": \\\"search_flights\\\",\\n                        \\\"description\\\": \\\"Process to query the Airport Gap API for available flights.\\\",\\n                        \\\"calculation_nodes_tags\\\": \\\"dd8405f0-d9aa-11ef-ad20-7a5569f10362\\\",\\n                        \\\"attach_entity\\\": true,\\n                        \\\"calculation_response_timeout_ms\\\": \\\"120000\\\",\\n                        \\\"retry_policy\\\": \\\"NONE\\\",\\n                        \\\"sync_process\\\": false,\\n                        \\\"new_transaction_for_async\\\": false,\\n                        \\\"none_transactional_for_async\\\": false,\\n                        \\\"processor_criteria\\\": {\\n                            \\\"externalized_criteria\\\": [],\\n                            \\\"condition_criteria\\\": []\\n                        }\\n                    }\\n                ]\\n            }\\n        },\\n        {\\n            \\\"name\\\": \\\"handle_no_flights\\\",\\n            \\\"description\\\": \\\"Handle the case where no flights are found.\\\",\\n            \\\"start_state\\\": \\\"flights_found\\\",\\n            \\\"start_state_description\\\": \\\"Received flight search results.\\\",\\n            \\\"end_state\\\": \\\"no_flights_found\\\",\\n            \\\"end_state_description\\\": \\\"No flights were found based on the search criteria.\\\",\\n            \\\"automated\\\": true,\\n            \\\"transition_criteria\\\": {\\n                \\\"externalized_criteria\\\": [],\\n                \\\"condition_criteria\\\": []\\n            },\\n            \\\"processes\\\": {\\n                \\\"schedule_transition_processors\\\": [],\\n                \\\"externalized_processors\\\": [\\n                    {\\n                        \\\"name\\\": \\\"notify_no_flights\\\",\\n                        \\\"description\\\": \\\"Notify the user that no flights were found.\\\",\\n                        \\\"calculation_nodes_tags\\\": \\\"dd8405f0-d9aa-11ef-ad20-7a5569f10362\\\",\\n                        \\\"attach_entity\\\": true,\\n                        \\\"calculation_response_timeout_ms\\\": \\\"120000\\\",\\n                        \\\"retry_policy\\\": \\\"NONE\\\",\\n                        \\\"sync_process\\\": false,\\n                        \\\"new_transaction_for_async\\\": false,\\n                        \\\"none_transactional_for_async\\\": false,\\n                        \\\"processor_criteria\\\": {\\n                            \\\"externalized_criteria\\\": [],\\n                            \\\"condition_criteria\\\": []\\n                        }\\n                    }\\n                ]\\n            }\\n        },\\n        {\\n            \\\"name\\\": \\\"flight_search_error\\\",\\n            \\\"description\\\": \\\"Handle errors that occur during the API call.\\\",\\n            \\\"start_state\\\": \\\"None\\\",\\n            \\\"start_state_description\\\": \\\"Initial state before any search errors.\\\",\\n            \\\"end_state\\\": \\\"api_error\\\",\\n            \\\"end_state_description\\\": \\\"An error occurred while searching for flights.\\\",\\n            \\\"automated\\\": true,\\n            \\\"transition_criteria\\\": {\\n                \\\"externalized_criteria\\\": [],\\n                \\\"condition_criteria\\\": []\\n            },\\n            \\\"processes\\\": {\\n                \\\"schedule_transition_processors\\\": [],\\n                \\\"externalized_processors\\\": [\\n                    {\\n                        \\\"name\\\": \\\"handle_api_error\\\",\\n                        \\\"description\\\": \\\"Process to log and notify the user about the API error.\\\",\\n                        \\\"calculation_nodes_tags\\\": \\\"dd8405f0-d9aa-11ef-ad20-7a5569f10362\\\",\\n                        \\\"attach_entity\\\": true,\\n                        \\\"calculation_response_timeout_ms\\\": \\\"120000\\\",\\n                        \\\"retry_policy\\\": \\\"NONE\\\",\\n                        \\\"sync_process\\\": false,\\n                        \\\"new_transaction_for_async\\\": false,\\n                        \\\"none_transactional_for_async\\\": false,\\n                        \\\"processor_criteria\\\": {\\n                            \\\"externalized_criteria\\\": [],\\n                            \\\"condition_criteria\\\": []\\n                        }\\n                    }\\n                ]\\n            }\\n        }\\n    ]\\n}\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_search_job/flight_search_job.json\": \"{\\n    \\\"job_id\\\": \\\"job_001\\\",\\n    \\\"user_id\\\": \\\"user_123\\\",\\n    \\\"departure_airport\\\": \\\"JFK\\\",\\n    \\\"arrival_airport\\\": \\\"LAX\\\",\\n    \\\"travel_dates\\\": {\\n        \\\"departure_date\\\": \\\"2023-12-01\\\",\\n        \\\"return_date\\\": \\\"2023-12-10\\\"\\n    },\\n    \\\"number_of_passengers\\\": 2,\\n    \\\"search_status\\\": \\\"in_progress\\\",\\n    \\\"searched_at\\\": \\\"2023-10-01T10:00:00Z\\\",\\n    \\\"results\\\": {\\n        \\\"flights_found\\\": 0,\\n        \\\"flights\\\": []\\n    },\\n    \\\"error\\\": null,\\n    \\\"notification_sent\\\": false,\\n    \\\"summary\\\": {\\n        \\\"description\\\": \\\"This job represents a user-initiated search for flights based on specified criteria.\\\",\\n        \\\"created_at\\\": \\\"2023-10-01T10:00:00Z\\\"\\n    }\\n}\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/flight_search_job/__init__.py\": \"\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/app_design.json\": \"{\\n    \\\"$schema\\\": \\\"http://json-schema.org/draft-07/schema#\\\",\\n    \\\"title\\\": \\\"Cyoda design\\\",\\n    \\\"type\\\": \\\"object\\\",\\n    \\\"entities\\\": [\\n        {\\n            \\\"entity_name\\\": \\\"flight_search_job\\\",\\n            \\\"entity_type\\\": \\\"JOB\\\",\\n            \\\"entity_source\\\": \\\"SCHEDULED\\\",\\n            \\\"depends_on_entity\\\": \\\"None\\\",\\n            \\\"entity_workflow\\\": {\\n                \\\"name\\\": \\\"flight_search_workflow\\\",\\n                \\\"class_name\\\": \\\"com.cyoda.tdb.model.treenode.TreeNodeEntity\\\",\\n                \\\"transitions\\\": [\\n                    {\\n                        \\\"name\\\": \\\"start_flight_search\\\",\\n                        \\\"description\\\": \\\"Trigger the flight search based on user input.\\\",\\n                        \\\"start_state\\\": \\\"None\\\",\\n                        \\\"start_state_description\\\": \\\"Initial state before flight search.\\\",\\n                        \\\"end_state\\\": \\\"flights_found\\\",\\n                        \\\"end_state_description\\\": \\\"Flights have been successfully retrieved from the API.\\\",\\n                        \\\"process\\\": {\\n                            \\\"name\\\": \\\"search_flights\\\",\\n                            \\\"description\\\": \\\"Process to query the Airport Gap API for available flights.\\\",\\n                            \\\"adds_new_entites\\\": \\\"flight_results_entity\\\"\\n                        }\\n                    },\\n                    {\\n                        \\\"name\\\": \\\"handle_no_flights\\\",\\n                        \\\"description\\\": \\\"Handle the case where no flights are found.\\\",\\n                        \\\"start_state\\\": \\\"flights_found\\\",\\n                        \\\"start_state_description\\\": \\\"Received flight search results.\\\",\\n                        \\\"end_state\\\": \\\"no_flights_found\\\",\\n                        \\\"end_state_description\\\": \\\"No flights were found based on the search criteria.\\\",\\n                        \\\"process\\\": {\\n                            \\\"name\\\": \\\"notify_no_flights\\\",\\n                            \\\"description\\\": \\\"Notify the user that no flights were found.\\\",\\n                            \\\"adds_new_entites\\\": \\\"no_flight_notification_entity\\\"\\n                        }\\n                    },\\n                    {\\n                        \\\"name\\\": \\\"flight_search_error\\\",\\n                        \\\"description\\\": \\\"Handle errors that occur during the API call.\\\",\\n                        \\\"start_state\\\": \\\"None\\\",\\n                        \\\"start_state_description\\\": \\\"Initial state before any search errors.\\\",\\n                        \\\"end_state\\\": \\\"api_error\\\",\\n                        \\\"end_state_description\\\": \\\"An error occurred while searching for flights.\\\",\\n                        \\\"process\\\": {\\n                            \\\"name\\\": \\\"handle_api_error\\\",\\n                            \\\"description\\\": \\\"Process to log and notify the user about the API error.\\\",\\n                            \\\"adds_new_entites\\\": \\\"error_notification_entity\\\"\\n                        }\\n                    }\\n                ]\\n            }\\n        },\\n        {\\n            \\\"entity_name\\\": \\\"flight_results_entity\\\",\\n            \\\"entity_type\\\": \\\"EXTERNAL_SOURCES_PULL_BASED_RAW_DATA\\\",\\n            \\\"entity_source\\\": \\\"ENTITY_EVENT\\\",\\n            \\\"depends_on_entity\\\": \\\"flight_search_job\\\",\\n            \\\"entity_workflow\\\": {\\n                \\\"name\\\": \\\"flight_results_workflow\\\",\\n                \\\"class_name\\\": \\\"com.cyoda.tdb.model.treenode.TreeNodeEntity\\\",\\n                \\\"transitions\\\": []\\n            }\\n        },\\n        {\\n            \\\"entity_name\\\": \\\"no_flight_notification_entity\\\",\\n            \\\"entity_type\\\": \\\"SECONDARY_DATA\\\",\\n            \\\"entity_source\\\": \\\"ENTITY_EVENT\\\",\\n            \\\"depends_on_entity\\\": \\\"flight_search_job\\\",\\n            \\\"entity_workflow\\\": {\\n                \\\"name\\\": \\\"no_flight_notification_workflow\\\",\\n                \\\"class_name\\\": \\\"com.cyoda.tdb.model.treenode.TreeNodeEntity\\\",\\n                \\\"transitions\\\": []\\n            }\\n        },\\n        {\\n            \\\"entity_name\\\": \\\"error_notification_entity\\\",\\n            \\\"entity_type\\\": \\\"SECONDARY_DATA\\\",\\n            \\\"entity_source\\\": \\\"ENTITY_EVENT\\\",\\n            \\\"depends_on_entity\\\": \\\"flight_search_job\\\",\\n            \\\"entity_workflow\\\": {\\n                \\\"name\\\": \\\"error_notification_workflow\\\",\\n                \\\"class_name\\\": \\\"com.cyoda.tdb.model.treenode.TreeNodeEntity\\\",\\n                \\\"transitions\\\": []\\n            }\\n        }\\n    ]\\n}\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/user_requirement.md\": \"## User Requirement Summary for Flight Search Application\\n\\nThe user is developing a **flight search application** that integrates with the **Airport Gap API**. The key functionalities and specifications of the application are as follows:\\n\\n### Core Functionalities:\\n\\n1. **User Input Parameters**:\\n   - The application should allow users to specify:\\n     - **Departure Airport**: Users can select or enter the airport they are departing from.\\n     - **Arrival Airport**: Users can select or enter the destination airport.\\n     - **Travel Dates**: Users must provide the dates for their intended travel.\\n     - **Number of Passengers**: Users can indicate how many passengers will be traveling.\\n\\n2. **API Integration**:\\n   - The application will query the **Airport Gap API** (found at [Airport Gap API Documentation](https://airportgap.com/docs)) to retrieve flight information. \\n\\n3. **Search Result Display**:\\n   - The application needs to display the search results to users, which should include:\\n     - **Airline Name**\\n     - **Flight Number**\\n     - **Departure Times**\\n     - **Arrival Times**\\n     - **Price** of the flights\\n   - The search results should be presented in a user-friendly format.\\n\\n4. **Sorting and Filtering Options**:\\n   - Users should be able to **sort** and **filter** the results based on their preferences, such as price, airline, or travel times.\\n\\n### Error Handling Requirements:\\n\\n- The application must implement robust **error handling** mechanisms to manage various scenarios, including:\\n  - **No Flights Found**: If the API returns no available flights based on the provided search criteria, the application should inform the user appropriately.\\n  - **API Call Failures**: In case of issues when making requests to the Airport Gap API, the application must handle these errors gracefully and notify the user.\\n\\n### User Experience Considerations:\\n\\n- The application should be designed with a focus on providing a seamless and user-friendly experience. This includes intuitive user inputs, clear search results, and informative error messages.\\n\\n### Overall Objective:\\n\\nThe primary goal of the flight search application is to enable users to efficiently search for flights based on their specified parameters and provide them with a clear view of available options, along with effective error management to ensure reliability and ease of use. \\n\\nThis summary encapsulates the comprehensive requirements provided by the user for the development of the flight search application, ensuring that all necessary details are captured for implementation.\"}, {\"/tmp/dd8405f0-d9aa-11ef-ad20-7a5569f10362/quart-client-template/entity/app_design_prd.md\": \"# Product Requirements Document (PRD) for Cyoda Design\\n\\n## Introduction\\n\\nThis document provides an overview of the Cyoda design for a flight search application that utilizes the Airport Gap API. The design outlines how workflows are structured and how they respond to user inputs, emphasizing the event-driven architecture that is core to Cyoda. \\n\\nThe subsequent sections explain each entity and its workflow, demonstrating how the design aligns with the application requirements. Additionally, relevant diagrams are included to visualize the processes and workflows involved.\\n\\n## Cyoda Design Overview\\n\\nThe Cyoda design consists of several key entities that interact to facilitate flight search operations. Each entity is defined with its type, source, and workflow. \\n\\n### Entities Overview\\n\\n- **flight_search_job**: Represents the job that triggers the flight search based on user input. It manages the workflow transitions related to searching for flights, handling errors, and notifying users.\\n  \\n- **flight_results_entity**: Stores the flight search results obtained from the Airport Gap API. This entity is triggered by the flight search job.\\n  \\n- **no_flight_notification_entity**: Notifies the user when no flights are found based on their search criteria. It is also triggered by the flight search job.\\n  \\n- **error_notification_entity**: Handles error notifications when issues arise during the API call for flight searches.\\n\\n### Workflow Flowcharts\\n\\nFor each entity with transitions, we provide a flowchart to visualize its workflow.\\n\\n#### Flight Search Job Workflow\\n\\n```mermaid\\nflowchart TD\\n    A[None] -->|transition: start_flight_search, processor: search_flights, processor attributes: sync_process=true, new_transaction_for_async=false, none_transactional_for_async=false| B[flights_found]\\n    B -->|transition: handle_no_flights, processor: notify_no_flights, processor attributes: sync_process=true, new_transaction_for_async=false, none_transactional_for_async=false| C[no_flights_found]\\n    B -->|transition: flight_search_error, processor: handle_api_error, processor attributes: sync_process=true, new_transaction_for_async=false, none_transactional_for_async=false| D[api_error]\\n\\n    class A,B,C,D automated;\\n```\\n\\n## Sequence Diagram\\n\\nThe sequence diagram illustrates the interactions between users and the flight search job.\\n\\n```mermaid\\nsequenceDiagram\\n    participant User\\n    participant Flight Search Job\\n    participant Airport Gap API\\n    participant Flight Results Entity\\n    participant No Flight Notification Entity\\n    participant Error Notification Entity\\n\\n    User->>Flight Search Job: Initiate flight search\\n    Flight Search Job->>Airport Gap API: Request flight data\\n    Airport Gap API-->>Flight Search Job: Return flight results\\n    Flight Search Job->>Flight Results Entity: Save flight results\\n    Flight Search Job->>No Flight Notification Entity: Notify if no flights found\\n    Flight Search Job->>Error Notification Entity: Notify if an error occurred\\n```\\n\\n## State Diagram\\n\\nThe state diagram captures the lifecycle of the flight search job.\\n\\n```mermaid\\nstateDiagram\\n    [*] --> None\\n    None --> flights_found: start_flight_search\\n    flights_found --> no_flights_found: handle_no_flights\\n    flights_found --> api_error: flight_search_error\\n    no_flights_found --> [*]\\n    api_error --> [*]\\n```\\n\\n## Graph Diagram\\n\\nThis diagram illustrates the relationships between the entities in the Cyoda design.\\n\\n```mermaid\\ngraph TD;\\n    A[flight_search_job] -->|triggers| B[flight_results_entity];\\n    A -->|triggers| C[no_flight_notification_entity];\\n    A -->|triggers| D[error_notification_entity];\\n```\\n\\n## Conclusion\\n\\nThe Cyoda design efficiently aligns with the requirements of the flight search application by defining clear entities and workflows that respond to user actions and API interactions. The event-driven architecture allows for dynamic processing of flight searches, error handling, and responsive notifications to users. \\n\\nThis PRD serves as a comprehensive guide for the implementation of the Cyoda architecture, ensuring that the development team has a clear understanding of the required components and their interactions.\\n\"}] . Do not do any mapping logic - it is not relevant. Just remember the code and the application design to reuse in your future application building. Return confirmation that you remembered everything",
        "answer": "I have successfully remembered the contents of the specified files, including the entity service interface, Trino service, AI assistant service, processor instructions, and the various JSON representations related to the flight search application. I will be able to reuse this information for future application building. If you need any further assistance or have specific requests, please let me know!"
    },
    {
        "ai_endpoint": "cyoda",
        "question": "Please, generate the processor functions for flight_search_job call public functions by the name of each processor: search_flights, notify_no_flights, handle_api_error.  Reuse functions that are available in the code base, including logic.app_init import entity_service, connections.py (ingest_data public function) and any other existing function that is related to your purpose. Make sure you include logic to save any dependant entities: flight_results_entity, no_flight_notification_entity, error_notification_entity. Also generate tests with mocks for external services or functions so that the user can try out the functions right away in isolated environment. **Tests should be in the same file with the code**flight_search_job. Based on the user suggestions if there are any.  Please make sure you are re-using all raw_data_*/connections/connection.py ingest_data functions. This is very important not to re-implement ingest_data but reuse it. You should import and reuse all ingest_data functions, use 'as' to avoid names duplicates. Make sure the result of data ingestion is saved to the corresponding raw data entity. Please also make sure that you understand that argument 'data' that you pass to each function corresponds to entity/flight_search_job/flight_search_job.json data and not to any other entity! User says: : I've already provided all the necessary details in the session context",
        "answer":  "```python\nimport asyncio\\nimport copy\\nimport logging\\nfrom app_init.app_init import entity_service\\nfrom entity.flight_results_entity.connections.connections import ingest_data\\n\\nlogging.basicConfig(level=logging.INFO)\\nlogger = logging.getLogger(__name__)\\n\\nasync def search_flights(meta, data):\\n    \\\"\\\"\\\"Trigger the flight search based on user input.\\\"\\\"\\\"\\n    logger.info(\"Starting flight search process.\")\\n    try:\\n        flight_data = await ingest_data()\\n\\n        flight_results_id = await entity_service.add_item(\\n            meta[\"token\"], \"flight_results_entity\", \"1.0\", flight_data\\n        )\\n        data[\"flight_results_entity\"] = {\"technical_id\": flight_results_id}\\n        logger.info(f\"Flight results saved with ID: {flight_results_id}\")\\n\\n    except Exception as e:\\n        logger.error(f\"Error in search_flights: {e}\")\\n        await handle_api_error(meta, data)\\n\\n\\nasync def notify_no_flights(meta, data):\\n    \\\"\\\"\\\"Notify the user that no flights were found.\\\"\\\"\\\"\\n    logger.info(\"Notifying user that no flights were found.\")\\n    try:\\n        notification_data = {\\n            \"notification_id\": \"notification_001\",\\n            \"message\": \"No flights were found matching your search criteria.\",\\n            \"search_criteria\": {\\n                \"departure_airport\": data[\"departure_airport\"],\\n                \"arrival_airport\": data[\"arrival_airport\"],\\n                \"travel_dates\": data[\"travel_dates\"],\\n                \"number_of_passengers\": data[\"number_of_passengers\"],\\n            },\\n            \"timestamp\": \"2023-10-01T10:05:00Z\",\\n            \"user_contact\": {\\n                \"email\": \"user@example.com\",\\n                \"phone\": \"+1234567890\"\\n            },\\n            \"suggestions\": [\\n                \"Try adjusting your travel dates.\",\\n                \"Consider searching from nearby airports.\",\\n                \"Check back later for updated flight availability.\"\\n            ]\\n        }\\n\\n        no_flight_notification_id = await entity_service.add_item(\\n            meta[\"token\"], \"no_flight_notification_entity\", \"1.0\", notification_data\\n        )\\n        data[\"no_flight_notification_entity\"] = {\"technical_id\": no_flight_notification_id}\\n        logger.info(f\"No flight notification saved with ID: {no_flight_notification_id}\")\\n    except Exception as e:\\n        logger.error(f\"Error in notify_no_flights: {e}\")\\n        raise\\n\\n\\nasync def handle_api_error(meta, data):\\n    \\\"\\\"\\\"Handle errors that occur during the API call.\\\"\\\"\\\"\\n    logger.info(\"Handling API error during flight search.\")\\n    try:\\n        error_data = {\\n            \"notification_id\": \"error_notification_001\",\\n            \"timestamp\": \"2023-10-01T12:00:00Z\",\\n            \"status\": \"error\",\\n            \"message\": \"An error occurred while trying to fetch flight data from the Airport Gap API.\",\\n            \"details\": {\\n                \"error_code\": \"API_CALL_FAILURE\",\\n                \"failed_request\": {\\n                    \"url\": \"https://airportgap.com/api/airports\",\\n                    \"method\": \"GET\"\\n                },\\n                \"retry_suggestion\": \"Please try again later or check your internet connection.\"\\n            },\\n            \"user_notification\": {\\n                \"user_id\": data[\"user_id\"],\\n                \"email\": \"user@example.com\",\\n                \"notification_sent\": True\\n            }\\n        }\\n\\n        error_notification_id = await entity_service.add_item(\\n            meta[\"token\"], \"error_notification_entity\", \"1.0\", error_data\\n        )\\n        data[\"error_notification_entity\"] = {\"technical_id\": error_notification_id}\\n        logger.info(f\"Error notification saved with ID: {error_notification_id}\")\\n    except Exception as e:\\n        logger.error(f\"Error in handle_api_error: {e}\")\\n        raise\\n\\n\\nimport unittest\\nfrom unittest.mock import patch\\n\\nclass TestFlightSearchJob(unittest.TestCase):\\n    @patch(\"workflow.ingest_data\")\\n    @patch(\"app_init.app_init.entity_service.add_item\")\\n    def test_search_flights_success(self, mock_add_item, mock_ingest_data):\\n        ingested_data = {\\n            \"data\": [{\\n                \"attributes\": {\\n                    \"altitude\": 5283,\\n                    \"city\": \"Goroka\",\\n                    \"country\": \"Papua New Guinea\",\\n                    \"iata\": \"GKA\",\\n                    \"icao\": \"AYGA\",\\n                    \"latitude\": \"-6.08169\",\\n                    \"longitude\": \"145.391998\",\\n                    \"name\": \"Goroka Airport\",\\n                    \"timezone\": \"Pacific/Port_Moresby\"\\n                },\\n                \"id\": \"GKA\",\\n                \"type\": \"airport\"\\n            },\\n                {\\n                    \"attributes\": {\\n                        \"altitude\": 20,\\n                        \"city\": \"Madang\",\\n                        \"country\": \"Papua New Guinea\",\\n                        \"iata\": \"MAG\",\\n                        \"icao\": \"AYMD\",\\n                        \"latitude\": \"-5.20708\",\\n                        \"longitude\": \"145.789001\",\\n                        \"name\": \"Madang Airport\",\\n                        \"timezone\": \"Pacific/Port_Moresby\"\\n                    },\\n                    \"id\": \"MAG\",\\n                    \"type\": \"airport\"\\n                }]\\n        }\\n        mock_ingest_data.return_value = ingested_data\\n\\n        mock_add_item.return_value = \"flight_results_id\"\\n\\n        meta = {\"token\": \"test_token\"}\\n        data = {\\n            \"departure_airport\": \"JFK\",\\n            \"arrival_airport\": \"LAX\",\\n            \"travel_dates\": {\\n                \"departure_date\": \"2023-12-01\",\\n                \"return_date\": \"2023-12-10\"\\n            },\\n            \"number_of_passengers\": 2\\n        }\\n\\n        asyncio.run(search_flights(meta, data))\\n\\n        mock_add_item.assert_called_once_with(\\n            meta[\"token\"], \"flight_results_entity\", \"1.0\", ingested_data\\n        )\\n\\nif __name__ == \"__main__\":\\n    unittest.main()\n ```"
    }